package main

import (
	"crypto/rand"
	"embed"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"mime/multipart"
	"net"
	"net/http"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"regexp"
	"strings"
	"sync"
	"syscall"
	"time"
	"unicode"
)

//go:embed static/upload.html static/download.html static/style.css
var staticFiles embed.FS

//go:embed kepubify
var kepubifyBinary []byte

const (
	maxUploadSize      = 800 * 1024 * 1024
	keyLength          = 4
	keyTimeout         = 30 * time.Second
	maxKeyAge          = 1 * time.Hour
	cleanupInterval    = 10 * time.Second
	mimeDetectBytes    = 512
	epubHeaderBytes    = 58
	epubPKSignature1   = 0x50
	epubPKSignature2   = 0x4B
	epubMimetypeOffset = 30
	epubMimetypeEnd    = 38
	epubMimeStart      = 38
	epubMimeEnd        = 58
)

type FileEntry struct {
	Key       string
	Filename  string
	Path      string
	Converted bool
	CreatedAt time.Time
	LastSeen  time.Time
	UserAgent string // User-Agent from key generation, kepubify only if contains "Kobo"
	mu        sync.Mutex
}

func (e *FileEntry) Touch() {
	e.mu.Lock()
	e.LastSeen = time.Now()
	e.mu.Unlock()
}

func (e *FileEntry) GetLastSeen() time.Time {
	e.mu.Lock()
	defer e.mu.Unlock()
	return e.LastSeen
}

type Server struct {
	store      sync.Map // map[string]*FileEntry
	uploadsDir string
}

func main() {
	port := os.Getenv("PORT")
	if port == "" {
		port = "3001"
	}

	server := &Server{
		uploadsDir: "uploads",
	}

	if err := os.MkdirAll(server.uploadsDir, 0755); err != nil {
		log.Fatal("Failed to create uploads directory:", err)
	}

	go server.cleanupRoutine()

	http.HandleFunc("/", server.handleRoot)
	http.HandleFunc("/upload", server.handleUpload)
	http.HandleFunc("/status/", server.handleStatus)
	http.HandleFunc("/generate", server.handleGenerate)
	http.Handle("/static/", http.FileServer(http.FS(staticFiles)))
	http.HandleFunc("/{filename}", server.handleDownload)

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-sigChan
		log.Println("Shutting down...")
		server.cleanupAllFiles()
		os.Exit(0)
	}()

	// Get network interfaces to display accessible addresses
	addrs, err := net.InterfaceAddrs()
	if err != nil {
		log.Printf("Warning: Could not get network interfaces: %v", err)
		log.Printf("Server starting on port %s", port)
	} else {
		log.Printf("Server starting on port %s", port)
		log.Println("Accessible at:")
		log.Printf("  http://localhost:%s (this machine only)", port)
		for _, addr := range addrs {
			if ipnet, ok := addr.(*net.IPNet); ok && !ipnet.IP.IsLoopback() {
				if ipnet.IP.To4() != nil {
					log.Printf("  http://%s:%s (network)", ipnet.IP.String(), port)
				}
			}
		}
	}

	if err := http.ListenAndServe(":"+port, nil); err != nil {
		log.Fatal("Server failed:", err)
	}
}

func (s *Server) handleRoot(w http.ResponseWriter, r *http.Request) {
	if r.URL.Path != "/" {
		s.handleDownload(w, r)
		return
	}

	userAgent := r.Header.Get("User-Agent")
	if !strings.Contains(userAgent, "Kobo") {
		http.Redirect(w, r, "/static/upload.html", http.StatusFound)
		return
	}

	content, err := staticFiles.ReadFile("static/download.html")
	if err != nil {
		http.Error(w, "Page not found", http.StatusNotFound)
		return
	}
	w.Header().Set("Content-Type", "text/html; charset=utf-8")
	w.Write(content)
}

func (s *Server) handleGenerate(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusMethodNotAllowed)
		json.NewEncoder(w).Encode(map[string]string{"error": "generate_requires_post_method"})
		return
	}

	key := generateKey()

	// Store the key with user agent info for validation later
	entry := &FileEntry{
		Key:       key,
		CreatedAt: time.Now(),
		LastSeen:  time.Now(),
		UserAgent: r.Header.Get("User-Agent"),
	}
	s.store.Store(key, entry)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]string{"key": key})
	log.Printf("Generated key %s for %s", key, r.RemoteAddr)
}

func (s *Server) handleUpload(w http.ResponseWriter, r *http.Request) {
	if r.Method != "POST" {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, maxUploadSize)
	if err := r.ParseMultipartForm(maxUploadSize); err != nil {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprint(w, "File too large (max 800MB)")
		return
	}

	key := strings.ToUpper(r.FormValue("key"))
	if len(key) != keyLength {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprint(w, "Invalid key length")
		return
	}

	// Check if key exists (was pre-generated by Kobo)
	value, exists := s.store.Load(key)
	if !exists {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Unknown key %s", key)
		return
	}

	// Update last seen time for existing key
	value.(*FileEntry).Touch()

	file, header, err := r.FormFile("file")
	if err != nil {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprint(w, "No file uploaded")
		return
	}
	defer file.Close()

	buffer := make([]byte, mimeDetectBytes)
	_, err = file.Read(buffer)
	if err != nil {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprint(w, "Cannot read file")
		return
	}
	file.Seek(0, 0)

	mimeType := http.DetectContentType(buffer)
	isEPUBMime := strings.HasPrefix(mimeType, "application/epub+zip") || strings.HasPrefix(mimeType, "application/zip")

	if !isEPUBMime && !isEPUB(file) {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusBadRequest)
		fmt.Fprintf(w, "Uploaded file is of an invalid type: %s (EPUB only)", header.Filename)
		return
	}
	file.Seek(0, 0)

	filename := sanitizeFilename(header.Filename)
	if !strings.HasSuffix(strings.ToLower(filename), ".epub") {
		filename += ".epub"
	}

	tempPath := filepath.Join(s.uploadsDir, fmt.Sprintf("%s_%s", key, filename))
	destFile, err := os.Create(tempPath)
	if err != nil {
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprint(w, "Failed to save file")
		return
	}
	defer destFile.Close()

	if _, err := io.Copy(destFile, file); err != nil {
		os.Remove(tempPath)
		w.Header().Set("Content-Type", "text/plain")
		w.WriteHeader(http.StatusInternalServerError)
		fmt.Fprint(w, "Failed to write file data")
		return
	}

	finalPath := tempPath
	converted := false

	// Get existing entry to check for Kobo user agent
	existingEntry, _ := value.(*FileEntry)
	shouldConvert := r.FormValue("kepubify") == "on" && existingEntry != nil && strings.Contains(existingEntry.UserAgent, "Kobo")

	if shouldConvert {
		if kepubPath := convertToKepub(tempPath); kepubPath != "" {
			os.Remove(tempPath)
			finalPath = kepubPath
			converted = true
			filename = strings.TrimSuffix(filename, ".epub") + ".kepub.epub"
		}
	}

	// Delete old file if it exists (when re-uploading to same key)
	if existingEntry.Path != "" && existingEntry.Path != finalPath {
		os.Remove(existingEntry.Path)
		log.Printf("Deleted old file %s for key %s (replaced with %s)", existingEntry.Filename, key, filename)
	}

	// Update existing entry with file info
	updatedEntry := &FileEntry{
		Key:       key,
		Filename:  filename,
		Path:      finalPath,
		Converted: converted,
		CreatedAt: existingEntry.CreatedAt, // Keep original creation time
		LastSeen:  time.Now(),
		UserAgent: existingEntry.UserAgent, // Keep original user agent from Kobo
	}
	s.store.Store(key, updatedEntry)

	// Send plain text response for JavaScript client
	message := fmt.Sprintf("Successfully uploaded: %s", filename)
	if converted {
		message = fmt.Sprintf("Successfully uploaded and converted: %s", filename)
	}
	w.Header().Set("Content-Type", "text/plain")
	w.WriteHeader(http.StatusOK)
	fmt.Fprint(w, message)
}

func (s *Server) handleStatus(w http.ResponseWriter, r *http.Request) {
	key := strings.ToUpper(strings.TrimPrefix(r.URL.Path, "/status/"))
	if len(key) != keyLength {
		w.Header().Set("Content-Type", "application/json")
		w.WriteHeader(http.StatusBadRequest)
		json.NewEncoder(w).Encode(map[string]string{"error": "invalid_key_length"})
		return
	}

	value, exists := s.store.Load(key)
	if !exists {
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(map[string]string{"error": "key_not_found_or_expired"})
		return
	}

	entry := value.(*FileEntry)
	entry.Touch()

	// Check if file has been uploaded
	ready := entry.Filename != "" && entry.Path != ""

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]interface{}{
		"ready":     ready,
		"filename":  entry.Filename,
		"converted": entry.Converted,
	})
}

func (s *Server) handleDownload(w http.ResponseWriter, r *http.Request) {
	filename := strings.TrimPrefix(r.URL.Path, "/")
	if filename == "" {
		http.NotFound(w, r)
		return
	}

	key := strings.ToUpper(r.URL.Query().Get("key"))
	if len(key) != keyLength {
		http.NotFound(w, r)
		return
	}

	value, exists := s.store.Load(key)
	if !exists {
		http.NotFound(w, r)
		return
	}

	entry := value.(*FileEntry)
	entry.Touch()

	if entry.Filename != filename {
		http.NotFound(w, r)
		return
	}

	file, err := os.Open(entry.Path)
	if err != nil {
		http.NotFound(w, r)
		return
	}
	defer file.Close()

	stat, err := file.Stat()
	if err != nil {
		http.NotFound(w, r)
		return
	}

	w.Header().Set("Content-Type", "application/epub+zip")
	w.Header().Set("Content-Disposition", fmt.Sprintf("attachment; filename=%q", entry.Filename))
	w.Header().Set("Content-Length", fmt.Sprintf("%d", stat.Size()))

	io.Copy(w, file)
}

func (s *Server) cleanupRoutine() {
	// Removes files after keyTimeout (30s) of inactivity or maxKeyAge (1hr)
	ticker := time.NewTicker(cleanupInterval)
	defer ticker.Stop()

	for range ticker.C {
		now := time.Now()
		s.store.Range(func(key, value interface{}) bool {
			entry := value.(*FileEntry)
			lastSeen := entry.GetLastSeen()
			createdAt := entry.CreatedAt

			isInactive := now.Sub(lastSeen) > keyTimeout
			isExpired := now.Sub(createdAt) > maxKeyAge
			if isInactive || isExpired {
				s.store.Delete(key)
				os.Remove(entry.Path)
				log.Printf("Cleaned up file: %s (key: %s)", entry.Filename, entry.Key)
			}
			return true
		})
	}
}

func (s *Server) cleanupAllFiles() {
	s.store.Range(func(key, value interface{}) bool {
		entry := value.(*FileEntry)
		os.Remove(entry.Path)
		s.store.Delete(key)
		return true
	})
}

func generateKey() string {
	const chars = "ABCDEFGHJKMNPQRSTUVWXYZ23456789"
	key := make([]byte, keyLength)

	if _, err := rand.Read(key); err != nil {
		panic("failed to generate secure random key")
	}

	for i := range key {
		key[i] = chars[int(key[i])%len(chars)]
	}

	return string(key)
}

func sanitizeFilename(filename string) string {
	filename = filepath.Base(filename)

	const asciiLimit = 128
	var result []rune
	for _, r := range filename {
		isASCII := r < asciiLimit
		isAllowedChar := unicode.IsLetter(r) || unicode.IsDigit(r) || r == '.' || r == '-' || r == '_' || r == ' '
		if isASCII && isAllowedChar {
			result = append(result, r)
		} else if r == '–' || r == '—' {
			result = append(result, '-')
		} else if unicode.IsSpace(r) {
			result = append(result, ' ')
		}
	}

	sanitized := string(result)
	sanitized = regexp.MustCompile(`\s+`).ReplaceAllString(sanitized, " ")
	sanitized = regexp.MustCompile(`\.+`).ReplaceAllString(sanitized, ".")
	sanitized = strings.TrimSpace(sanitized)

	if sanitized == "" {
		sanitized = "book"
	}

	return sanitized
}

func isEPUB(file multipart.File) bool {
	// EPUB must be a ZIP (PK) with "mimetype" as first file containing "application/epub+zip"
	buffer := make([]byte, epubHeaderBytes)
	n, err := file.Read(buffer)
	if err != nil || n < epubHeaderBytes {
		return false
	}

	hasPKSignature := buffer[0] == epubPKSignature1 && buffer[1] == epubPKSignature2
	hasMimetypeEntry := string(buffer[epubMimetypeOffset:epubMimetypeEnd]) == "mimetype"
	hasEPUBMimetype := string(buffer[epubMimeStart:epubMimeEnd]) == "application/epub+zip"

	return hasPKSignature && hasMimetypeEntry && hasEPUBMimetype
}

func convertToKepub(epubPath string) string {
	if len(kepubifyBinary) == 0 {
		log.Println("Kepubify binary not available, skipping conversion")
		return ""
	}

	tempDir := os.TempDir()
	kepubifyPath := filepath.Join(tempDir, "kepubify-"+generateKey())
	if err := os.WriteFile(kepubifyPath, kepubifyBinary, 0755); err != nil {
		log.Printf("failed to extract kepubify: %v", err)
		return ""
	}
	defer os.Remove(kepubifyPath) // Clean up after conversion

	kepubPath := strings.TrimSuffix(epubPath, ".epub") + ".kepub.epub"
	cmd := exec.Command(kepubifyPath, "-o", kepubPath, epubPath)

	if err := cmd.Run(); err != nil {
		log.Printf("kepubify conversion failed: %v", err)
		return ""
	}

	return kepubPath
}
